import { toBlob } from "https://cdn.jsdelivr.net/npm/html-to-image@1.11.11/+esm";
import yaml from "https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/+esm";
import Papa from "https://cdn.jsdelivr.net/npm/papaparse@5.4.1/+esm";
import { Community_DATA } from "./community-data.js";
import { CONFIG } from "./config.js";

// ========== DOM ==========
const el = {
  status: document.getElementById("status"),
  themeToggle: document.getElementById("themeToggle"),
  // Setup
  setupPanel: document.getElementById("setupPanel"),
  playerCountGroup: document.getElementById("playerCountGroup"),
  seatGroup: document.getElementById("seatGroup"),
  lorePerPlayerGroup: document.getElementById("lorePerPlayerGroup"),
  customLoreSettings: document.getElementById("customLoreSettings"),
  customLoreSliders: document.getElementById("customLoreSliders"),
  leaderPoolSize: document.getElementById("leaderPoolSize"),
  lorePoolSize: document.getElementById("lorePoolSize"),
  acceptableSpread: document.getElementById("acceptableSpread"),
  minScore: document.getElementById("minScore"),
  maxScore: document.getElementById("maxScore"),
  minScoreDisplay: document.getElementById("minScoreDisplay"),
  maxScoreDisplay: document.getElementById("maxScoreDisplay"),
  tierSourceGroup: document.getElementById("tierSourceGroup"),
  customTierInput: document.getElementById("customTierInput"),
  customTierUrl: document.getElementById("customTierUrl"),
  customTierText: document.getElementById("customTierText"),
  customTierLoad3P: document.getElementById("customTierLoad3P"),
  customTierLoad4P: document.getElementById("customTierLoad4P"),
  customTierStatus: document.getElementById("customTierStatus"),
  tierScoringGroup: document.getElementById("tierScoringGroup"),
  leaderWeight: document.getElementById("leaderWeight"),
  weightDisplay: document.getElementById("weightDisplay"),
  leaderPool: document.getElementById("leaderPool"),
  lorePool: document.getElementById("lorePool"),
  leaderPoolCount: document.getElementById("leaderPoolCount"),
  lorePoolCount: document.getElementById("lorePoolCount"),
  randomLeaders: document.getElementById("randomLeaders"),
  randomLore: document.getElementById("randomLore"),
  clearLeaders: document.getElementById("clearLeaders"),
  clearLore: document.getElementById("clearLore"),
  balancedDraft: document.getElementById("balancedDraft"),
  balancedSettingsToggle: document.getElementById("balancedSettingsToggle"),
  balancedSettings: document.getElementById("balancedSettings"),
  leaderTierConstraint: document.getElementById("leaderTierConstraint"),
  loreTierConstraint: document.getElementById("loreTierConstraint"),
  handicapSliders: document.getElementById("handicapSliders"),
  startDraft: document.getElementById("startDraft"),
  draftOrderGroup: document.getElementById("draftOrderGroup"),
  // Draft
  draftPanel: document.getElementById("draftPanel"),
  draftPhaseLabel: document.getElementById("draftPhaseLabel"),
  playerBoards: document.getElementById("playerBoards"),
  availableCards: document.getElementById("availableCards"),
  autoDraftBtn: document.getElementById("autoDraftBtn"),
  undoBtn: document.getElementById("undoBtn"),
  resetDraft: document.getElementById("resetDraft"),
  resetAllBtn: document.getElementById("resetAllBtn"),
  saveDraftImg: document.getElementById("saveDraftImg"),
};

// ========== State ==========
let allLeaders = []; // { name, tier, value, card }
let allLore = [];
let selectedLeaders = new Set();
let selectedLore = new Set();

// Store all tier sources
let personalLeaders = [];
let personalLore = [];
let personal3PLeaders = [];
let personal4PLeaders = [];
let personalBasecourt = [];
let dataLeaders = [];
let dataLore = [];
let customLeaders = [];
let customLore = [];
let Community3pLeaders = [];
let Community3pLore = [];
let Community4pLeaders = [];
let Community4pLore = [];

let draft = {
  numPlayers: 3,
  mySeat: 1,
  lorePerPlayer: 1, // Can be a number or "custom"
  customLoreCounts: [1, 1, 1], // Array of lore counts per player when using custom
  tierSource: "personal3p",
  tierScoring: "varied",
  leaderTierConstraint: "any",
  loreTierConstraint: "any",
  leaderWeight: 3,
  loreWeight: 1,
  handicaps: [0, 0, 0], // Handicap values for each player (0-9)
  draftOrder: "descending", // 'descending' or 'snake'
  generatedByBalanced: false, // Track if draft was generated by balanced generator
  // Draft state
  active: false,
  pickIndex: 0,
  order: [],
  players: [], // [{ leader: null, lore: [] }]
  availableLeaders: [],
  availableLore: [],
  history: [],
};

// ========== Utilities ==========
function setStatus(msg, { isError = false } = {}) {
  el.status.textContent = msg;
  el.status.classList.toggle("error", isError);
  el.status.style.display = msg ? "" : "none";
}

function normalizeText(s) {
  return String(s ?? "").trim().toLowerCase().replace(/['\u2019]/g, "'").replace(/\s+/g, " ");
}

async function fetchText(url) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
  try {
    const res = await fetch(url, { cache: "no-store", signal: controller.signal });
    clearTimeout(timeoutId);
    if (!res.ok) throw new Error(`Fetch failed ${res.status}: ${url}`);
    const text = await res.text();
    if (text.includes("accounts.google.com") && text.includes("Sign in")) {
      throw new Error("Google requires login. Make the sheet public.");
    }
    return text;
  } catch (err) {
    clearTimeout(timeoutId);
    if (err.name === 'AbortError') {
      throw new Error(`Fetch timed out: ${url}`);
    }
    throw err;
  }
}

function getImageUrl(card) {
  if (!card?.image) return null;
  return `${CONFIG.cardImagesBaseUrl}${encodeURIComponent(card.image)}.png`;
}

// ========== Theme ==========
function initTheme() {
  const saved = localStorage.getItem("arcs-theme");
  if (saved) document.documentElement.dataset.theme = saved;
}

function toggleTheme() {
  const current = document.documentElement.dataset.theme || "dark";
  const next = current === "dark" ? "light" : "dark";
  document.documentElement.dataset.theme = next;
  localStorage.setItem("arcs-theme", next);
}

// ========== Scoring ==========
const TIER_BASE = { SSS: 7, SS: 6, S: 5, A: 4, B: 3, C: 2, D: 1, F: 0 };
const TIER_ORDER = ["SSS", "SS", "S", "A", "B", "C", "D", "F"];

// Leader-Lore synergies: { leader: string, lore: string, bonus: number | function(numPlayers) }
const SYNERGIES = [
  { leader: "Noble", lore: "Tycoon's Ambition", bonus: 6 },
  { leader: "Mystic", lore: "Living Structures", bonus: 4 },
  { leader: "Upstart", lore: "Tycoon's Ambition", bonus: 3 },
  { leader: "Demagogue", lore: "Tycoon's Ambition", bonus: 6 },
  { leader: "Fuel-Drinker", lore: "Living Structures", bonus: 3 },
  { leader: "Fuel-Drinker", lore: "Tycoon's Charm", bonus: (numPlayers) => numPlayers === 3 ? 6 : 3 },
  { leader: "Agitator", lore: "Living Structures", bonus: 3 },
  { leader: "Anarchist", lore: "Living Structures", bonus: (numPlayers) => draft.generatedByBalanced ? -4 : -2 },
];

function assignValues(entries) {
  // Group by tier, assign sub-values within each tier based on position
  const grouped = new Map();
  for (const tier of TIER_ORDER) grouped.set(tier, []);
  for (const e of entries) {
    const t = TIER_ORDER.includes(e.tier) ? e.tier : "D";
    grouped.get(t).push(e);
  }

  // "same" → all cards in a tier get the exact base score
  // "varied" → spread within the tier based on position, capped at 1/3rd of 0.3 per jump
  for (const [tier, items] of grouped) {
    const base = TIER_BASE[tier];
    const n = items.length;
    const maxStep = 0.3 / 3; // 1/3rd of 0.3
    const spread = draft.tierScoring === "varied" ? Math.min(0.5, maxStep * (n - 1)) : 0;
    for (let i = 0; i < n; i++) {
      const sub = n > 1 ? ((n - 1 - 2 * i) / (2 * (n - 1))) * spread : 0;
      items[i].value = Math.max(0, base + sub);
    }
  }
}

function getWeightedScore(entry, type) {
  const w = type === "leader" ? draft.leaderWeight : draft.loreWeight;
  return entry.value * w;
}

function getLoreCountForPlayer(playerIndex, draftObj = draft) {
  if (draftObj.lorePerPlayer === "custom") {
    return draftObj.customLoreCounts[playerIndex] || 0;
  }
  return draftObj.lorePerPlayer;
}

function getSynergyBonus(player) {
  let bonus = 0;
  for (const synergy of SYNERGIES) {
    if (player.leader && player.leader.name === synergy.leader) {
      const hasLore = player.lore.some(l => l.name === synergy.lore);
      if (hasLore) {
        const synergyBonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
        bonus += synergyBonus;
      }
    }
  }
  return bonus;
}

function playerTotalScore(player, playerIndex) {
  let score = 0;
  if (player.leader) score += getWeightedScore(player.leader, "leader");
  for (const l of player.lore) score += getWeightedScore(l, "lore");
  
  // Add synergy bonuses
  score += getSynergyBonus(player);
  
  // Add handicap bonus (1 handicap = 1x leader weight)
  const handicap = draft.handicaps[playerIndex] || 0;
  score += handicap * draft.leaderWeight;
  
  return score;
}

// ========== Data Loading ==========
async function loadCards() {
  const text = await fetchText(CONFIG.cardsYamlUrl);
  const data = yaml.load(text);
  if (!Array.isArray(data)) throw new Error("Invalid YAML");
  return data
    .filter((c) => c && typeof c === "object" && c.name)
    .map((c) => ({
      id: c.id ?? null,
      name: c.name ?? "",
      image: c.image ?? null,
      tags: Array.isArray(c.tags) ? c.tags : [],
      text: c.text ?? "",
    }));
}

async function loadTierList() {
  const text = await fetchText(CONFIG.tierListCsvUrl);
  const parsed = Papa.parse(text, { header: false, skipEmptyLines: false });
  return parsed.data ?? [];
}

async function loadRankedSheet() {
  const text = await fetchText(CONFIG.sheetCsvUrl);
  const parsed = Papa.parse(text, { header: false, skipEmptyLines: false });
  return parsed.data ?? [];
}

function parseRankedData(rows, cards) {
  const cardMap = new Map();
  for (const c of cards) cardMap.set(normalizeText(c.name), c);

  // Parse the ranked sheet (same format as app.js parseLeadersLoreSheet)
  const stats = [];
  let headerRowIdx = -1;
  for (let i = 0; i < Math.min(10, rows.length); i++) {
    if (rows[i] && normalizeText(rows[i][0]) === "leader") {
      headerRowIdx = i;
      break;
    }
  }
  if (headerRowIdx === -1) return { leaders: [], lore: [] };

  const headerRow = rows[headerRowIdx];
  let loreColIdx = -1;
  for (let i = 0; i < headerRow.length; i++) {
    if (normalizeText(headerRow[i]) === "lore") { loreColIdx = i; break; }
  }

  for (let i = headerRowIdx + 1; i < rows.length; i++) {
    const row = rows[i];
    if (!row) continue;
    const leaderName = (row[0] ?? "").trim();
    if (leaderName) {
      stats.push({
        name: leaderName,
        type: "Leader",
        winRate: parseFloat((row[3] ?? "").replace("%", "")) || 0,
      });
    }
    if (loreColIdx > 0) {
      const loreName = (row[loreColIdx] ?? "").trim();
      if (loreName) {
        stats.push({
          name: loreName,
          type: "Lore",
          winRate: parseFloat((row[loreColIdx + 3] ?? "").replace("%", "")) || 0,
        });
      }
    }
  }

  // Sort each type by win rate descending, assign tiers by percentile
  function assignTierByPercentile(sorted, idx) {
    const pct = (idx / sorted.length) * 100;
    if (pct <= 10) return "S";
    if (pct <= 30) return "A";
    if (pct <= 70) return "B";
    if (pct <= 90) return "C";
    return "D";
  }

  const leaderStats = stats.filter((s) => s.type === "Leader").sort((a, b) => b.winRate - a.winRate);
  const loreStats = stats.filter((s) => s.type === "Lore").sort((a, b) => b.winRate - a.winRate);

  const leaders = leaderStats.map((s, idx) => ({
    name: s.name,
    tier: assignTierByPercentile(leaderStats, idx),
    value: 0,
    card: cardMap.get(normalizeText(s.name)) ?? null,
  }));

  const lore = loreStats.map((s, idx) => ({
    name: s.name,
    tier: assignTierByPercentile(loreStats, idx),
    value: 0,
    card: cardMap.get(normalizeText(s.name)) ?? null,
  }));

  assignValues(leaders);
  assignValues(lore);
  return { leaders, lore };
}

function parseCommunityTierData(playerCount, cards) {
  const data = Community_DATA[playerCount];
  if (!data) return { leaders: [], lore: [] };

  const cardMap = new Map();
  for (const c of cards) cardMap.set(normalizeText(c.name), c);

  function assignTierByPercentile(sorted, idx) {
    const pct = (idx / sorted.length) * 100;
    if (pct <= 10) return "S";
    if (pct <= 30) return "A";
    if (pct <= 70) return "B";
    if (pct <= 90) return "C";
    return "D";
  }

  // Sort by win rate descending
  const leaderEntries = Object.entries(data.leaderWinrates)
    .sort((a, b) => b[1] - a[1]);
  const loreEntries = Object.entries(data.loreWinrates)
    .sort((a, b) => b[1] - a[1]);

  const leaders = leaderEntries.map(([name, winRate], idx) => ({
    name,
    tier: assignTierByPercentile(leaderEntries, idx),
    value: 0,
    card: cardMap.get(normalizeText(name)) ?? null,
  }));

  const lore = loreEntries.map(([name, winRate], idx) => ({
    name,
    tier: assignTierByPercentile(loreEntries, idx),
    value: 0,
    card: cardMap.get(normalizeText(name)) ?? null,
  }));

  assignValues(leaders);
  assignValues(lore);
  return { leaders, lore };
}

function parseTierData(rows, cards) {
  // Sheet format: Name | Tier  OR  "Name,Tier" in single column
  // Empty rows separate 3P leaders, 4P leaders, lore, and base court
  // First row is header (Name, Tier) or (Name,Tier)
  const leaders3P = [];
  const leaders4P = [];
  const lore = [];
  const basecourt = [];
  let section = 0; // 0 = 3P leaders, 1 = 4P leaders, 2 = lore, 3 = base court
  let headerSkipped = false;

  // Build a lookup map: normalized name → card
  const cardMap = new Map();
  for (const card of cards) {
    cardMap.set(normalizeText(card.name), card);
  }

  for (const row of rows) {
    let name, tier;

    if (row.length === 1) {
      // Single column: "Name,Tier"
      const cell = (row[0] ?? "").trim();
      if (cell.includes(",")) {
        [name, tier] = cell.split(",", 2).map(s => s.trim());
      } else {
        name = cell;
        tier = "";
      }
    } else {
      // Two columns: Name | Tier
      name = (row[0] ?? "").trim();
      tier = (row[1] ?? "").trim();
    }
    tier = tier.toUpperCase();

    // Skip header row
    if (!headerSkipped) {
      if (normalizeText(name) === "name") {
        headerSkipped = true;
        continue;
      }
    }

    // Empty row = separator between sections
    if (!name && !tier) {
      if (headerSkipped) {
        section++;
        if (section > 3) break; // Stop after base court section
      }
      continue;
    }

    if (!name || !tier) continue;

    const card = cardMap.get(normalizeText(name));
    const entry = {
      name,
      tier,
      value: 0,
      card: card ?? null,
    };

    if (section === 0) {
      leaders3P.push(entry);
    } else if (section === 1) {
      leaders4P.push(entry);
    } else if (section === 2) {
      lore.push(entry);
    } else if (section === 3) {
      basecourt.push(entry);
    }
  }

  assignValues(leaders3P);
  assignValues(leaders4P);
  assignValues(lore);
  assignValues(basecourt);
  return { leaders3P, leaders4P, lore, basecourt };
}

// ========== Draft Order ==========
function buildDraftOrder(numPlayers) {
  if (draft.draftOrder === "snake") {
    // Snake: 3,2,1,1,2,3,3,2,1... for 3 players (or N..1,1..N, repeat)
    const order = [];
    // Repeat enough times to cover all picks (let's make a long enough pattern)
    // Typically, the draft order is N..1,1..N,N..1,1..N,...
    // We'll make a pattern of length 2*numPlayers
    for (let i = numPlayers; i >= 1; i--) order.push(i);
    for (let i = 1; i <= numPlayers; i++) order.push(i);
    return order;
  } else {
    // Descending: N, N-1, ..., 1 repeating
    const order = [];
    for (let i = numPlayers; i >= 1; i--) order.push(i);
    return order;
  }
}

function getCurrentDrafter() {
  const idx = draft.pickIndex % draft.order.length;
  return draft.order[idx]; // 1-based player number
}

// ========== Setup UI ==========
function initSetupUI() {
    // Draft order selector
    setupBtnGroup(el.draftOrderGroup, (val) => {
      draft.draftOrder = val;
    });
  // Button groups
  setupBtnGroup(el.playerCountGroup, (val) => {
    const prevNumPlayers = draft.numPlayers;
    draft.numPlayers = parseInt(val);
    const newNumPlayers = draft.numPlayers;

    function switchTierSource(newSource) {
      const prevActive = el.tierSourceGroup.querySelector('.active');
      if (prevActive) prevActive.classList.remove('active');
      const btn = el.tierSourceGroup.querySelector(`[data-value="${newSource}"]`);
      if (btn) btn.classList.add('active');
      draft.tierSource = newSource;
      el.customTierInput.classList.toggle("hidden", draft.tierSource !== "custom");
      applyTierSource();
    }

    // Map 3P <-> 4P for personal and community tier sources
    if (prevNumPlayers === 3 && newNumPlayers === 4) {
      if (draft.tierSource === "personal3p") switchTierSource("personal4p");
      else if (draft.tierSource === "Community3p") switchTierSource("Community4p");
    } else if (prevNumPlayers === 4 && newNumPlayers === 3) {
      if (draft.tierSource === "personal4p") switchTierSource("personal3p");
      else if (draft.tierSource === "Community4p") switchTierSource("Community3p");
    }

    // If switching from 4P down to 2P, fallback to the 3P tier lists for personal/community
    if (prevNumPlayers === 4 && newNumPlayers === 2) {
      if (draft.tierSource === "personal4p") switchTierSource("personal3p");
      else if (draft.tierSource === "Community4p") switchTierSource("Community3p");
    }
    // Adjust custom lore counts array size
    if (Array.isArray(draft.customLoreCounts)) {
      if (draft.numPlayers > draft.customLoreCounts.length) {
        // Add default values for new players
        const defaultValue = draft.lorePerPlayer === "custom" ? 1 : draft.lorePerPlayer;
        while (draft.customLoreCounts.length < draft.numPlayers) {
          draft.customLoreCounts.push(defaultValue);
        }
      } else if (draft.numPlayers < draft.customLoreCounts.length) {
        // Remove excess values
        draft.customLoreCounts = draft.customLoreCounts.slice(0, draft.numPlayers);
      }
    }
    // Adjust handicaps array size
    if (Array.isArray(draft.handicaps)) {
      if (draft.numPlayers > draft.handicaps.length) {
        // Add default values (0) for new players
        while (draft.handicaps.length < draft.numPlayers) {
          draft.handicaps.push(0);
        }
      } else if (draft.numPlayers < draft.handicaps.length) {
        // Remove excess values
        draft.handicaps = draft.handicaps.slice(0, draft.numPlayers);
      }
    }
    updateDefaults();
    updateSeatButtons();
    updateHandicapSliders();
    if (draft.lorePerPlayer === "custom") {
      updateCustomLoreSliders();
    }
    updatePoolCounts();
  });

  setupBtnGroup(el.seatGroup, (val) => {
    draft.mySeat = parseInt(val);
  });

  setupBtnGroup(el.lorePerPlayerGroup, (val) => {
    if (val === "custom") {
      draft.lorePerPlayer = "custom";
      el.customLoreSettings.style.display = "block";
      updateCustomLoreSliders();
    } else {
      draft.lorePerPlayer = parseInt(val);
      el.customLoreSettings.style.display = "none";
      // Set all custom counts to the selected value
      draft.customLoreCounts = Array(draft.numPlayers).fill(parseInt(val));
    }
    updateDefaults();
    updatePoolCounts();
  });

  el.leaderPoolSize.addEventListener("change", () => updatePoolCounts());
  el.lorePoolSize.addEventListener("change", () => updatePoolCounts());

  el.leaderWeight.addEventListener("input", () => {
    draft.leaderWeight = parseFloat(el.leaderWeight.value);
    el.weightDisplay.textContent = `${draft.leaderWeight}×`;
  });

  // Score range inputs
  el.minScore.addEventListener("input", () => {
    const minVal = parseInt(el.minScore.value);
    const maxVal = parseInt(el.maxScore.value);
    el.minScoreDisplay.textContent = minVal;
    if (minVal > maxVal) {
      el.maxScore.value = minVal;
      el.maxScoreDisplay.textContent = minVal;
    }
  });

  el.maxScore.addEventListener("input", () => {
    const minVal = parseInt(el.minScore.value);
    const maxVal = parseInt(el.maxScore.value);
    el.maxScoreDisplay.textContent = maxVal;
    if (maxVal < minVal) {
      el.minScore.value = maxVal;
      el.minScoreDisplay.textContent = maxVal;
    }
  });

  // Tier source toggle
  for (const btn of el.tierSourceGroup.querySelectorAll(".btn-option")) {
    btn.addEventListener("click", () => {
      el.tierSourceGroup.querySelector(".active").classList.remove("active");
      btn.classList.add("active");
      draft.tierSource = btn.dataset.value;
      el.customTierInput.classList.toggle("hidden", draft.tierSource !== "custom");
      if (draft.tierSource !== "custom") applyTierSource();
    });
  }

  // Custom tier loading
  el.customTierLoad3P.addEventListener("click", () => loadCustomTierData("3p"));
  el.customTierLoad4P.addEventListener("click", () => loadCustomTierData("4p"));

  // Tier scoring toggle
  for (const btn of el.tierScoringGroup.querySelectorAll(".btn-option")) {
    btn.addEventListener("click", () => {
      el.tierScoringGroup.querySelector(".active").classList.remove("active");
      btn.classList.add("active");
      draft.tierScoring = btn.dataset.value;
      assignValues(allLeaders);
      assignValues(allLore);
      renderPoolCards();
    });
  }

  el.randomLeaders.addEventListener("click", () => randomizePool("leader"));
  el.randomLore.addEventListener("click", () => randomizePool("lore"));
  el.clearLeaders.addEventListener("click", () => clearPool("leader"));
  el.clearLore.addEventListener("click", () => clearPool("lore"));
  el.balancedDraft.addEventListener("click", generateBalancedDraft);
  el.balancedSettingsToggle.addEventListener("click", () => {
    el.balancedSettings.classList.toggle("hidden");
  });
  setupBtnGroup(el.leaderTierConstraint, (val) => { draft.leaderTierConstraint = val; });
  setupBtnGroup(el.loreTierConstraint, (val) => { draft.loreTierConstraint = val; });
  el.startDraft.addEventListener("click", startDraft);

  // (Simulate Drafts UI removed)

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function buildSimDraftOrder(numPlayers, orderType) {
    if (orderType === "snake") {
      const order = [];
      for (let i = numPlayers; i >= 1; i--) order.push(i);
      for (let i = 1; i <= numPlayers; i++) order.push(i);
      return order;
    } else {
      const order = [];
      for (let i = numPlayers; i >= 1; i--) order.push(i);
      return order;
    }
  }

  updateDefaults();
  updateSeatButtons();
}

function setupBtnGroup(container, onChange) {
  container.querySelectorAll(".btn-option").forEach((btn) => {
    btn.addEventListener("click", () => {
      container.querySelectorAll(".btn-option").forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      onChange(btn.dataset.value);
    });
  });
}

function updateDefaults() {
  const n = draft.numPlayers;
  el.leaderPoolSize.value = n + 1;
  const totalLoreNeeded = draft.lorePerPlayer === "custom" 
    ? draft.customLoreCounts.reduce((sum, count) => sum + count, 0)
    : n * draft.lorePerPlayer;
  el.lorePoolSize.value = totalLoreNeeded + 1;
  selectedLeaders.clear();
  selectedLore.clear();
  renderPoolCards();
  updatePoolCounts();
  validateStartButton();
}

function updateSeatButtons() {
  const n = draft.numPlayers;
  const labels = ["1st", "2nd", "3rd", "4th"];
  el.seatGroup.innerHTML = "";
  for (let i = 1; i <= n; i++) {
    const btn = document.createElement("button");
    btn.className = "btn-option" + (i === draft.mySeat ? " active" : "");
    btn.dataset.value = i;
    btn.textContent = labels[i - 1];
    btn.addEventListener("click", () => {
      el.seatGroup.querySelectorAll(".btn-option").forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      draft.mySeat = i;
    });
    el.seatGroup.appendChild(btn);
  }
  if (draft.mySeat > n) {
    draft.mySeat = 1;
    el.seatGroup.querySelector(".btn-option").classList.add("active");
  }
}

function updateCustomLoreSliders() {
  el.customLoreSliders.innerHTML = "";
  for (let i = 0; i < draft.numPlayers; i++) {
    const playerDiv = document.createElement("div");
    playerDiv.className = "custom-lore-player";

    const label = document.createElement("label");
    label.textContent = `P${i + 1}`;

    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "0";
    slider.max = "9";
    slider.value = draft.customLoreCounts[i] || 0;
    slider.addEventListener("input", () => {
      draft.customLoreCounts[i] = parseInt(slider.value);
      countDisplay.textContent = slider.value;
      updatePoolCounts();
    });

    const countDisplay = document.createElement("span");
    countDisplay.className = "lore-count";
    countDisplay.textContent = slider.value;

    playerDiv.appendChild(label);
    playerDiv.appendChild(slider);
    playerDiv.appendChild(countDisplay);
    el.customLoreSliders.appendChild(playerDiv);
  }
}

function updateHandicapSliders() {
  el.handicapSliders.innerHTML = "";
  for (let i = 0; i < draft.numPlayers - 1; i++) {
    const playerDiv = document.createElement("div");
    playerDiv.className = "handicap-player";

    const label = document.createElement("label");
    label.textContent = `P${i + 1}`;

    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = "0";
    slider.max = "9";
    slider.value = draft.handicaps[i] || 0;
    
    slider.addEventListener("input", () => {
      let newValue = parseInt(slider.value);
      
      draft.handicaps[i] = newValue;
      
      // Ensure the lowest handicap is always 0
      const minHandicap = Math.min(...draft.handicaps);
      if (minHandicap > 0) {
        // Find the player with the current minimum and set them to 0
        const minIndex = draft.handicaps.indexOf(minHandicap);
        draft.handicaps[minIndex] = 0;
        // Update the corresponding slider display
        const allSliders = el.handicapSliders.querySelectorAll("input[type='range']");
        if (allSliders[minIndex]) {
          allSliders[minIndex].value = 0;
          allSliders[minIndex].nextElementSibling.textContent = 0;
        }
      }
      
      countDisplay.textContent = newValue;
    });

    const countDisplay = document.createElement("span");
    countDisplay.className = "handicap-count";
    countDisplay.textContent = slider.value;

    playerDiv.appendChild(label);
    playerDiv.appendChild(slider);
    playerDiv.appendChild(countDisplay);
    el.handicapSliders.appendChild(playerDiv);
  }
}

function renderPoolCards() {
  renderPoolSection(el.leaderPool, allLeaders, selectedLeaders, "leader");
  renderPoolSection(el.lorePool, allLore, selectedLore, "lore");
}

function renderPoolSection(container, entries, selected, type) {
  container.innerHTML = "";
  for (const entry of entries) {
    const btn = document.createElement("button");
    btn.className = "pool-card" + (selected.has(entry.name) ? " selected" : "");

    const imgUrl = entry.card ? getImageUrl(entry.card) : null;
    let imgHTML = "";
    if (imgUrl) {
      imgHTML = `<img class="pool-card-img" src="${imgUrl}" alt="${entry.name}" loading="lazy" />`;
    }

    // Add synergy info
    let hasSynergy = false;
    for (const synergy of SYNERGIES) {
      if ((type === "leader" && entry.name === synergy.leader) || (type === "lore" && entry.name === synergy.lore)) {
        hasSynergy = true;
        break;
      }
    }
    const synergyBadge = hasSynergy ? '<span class="synergy-badge">★</span>' : '';
    
    btn.innerHTML = `${imgHTML}<span class="tier-badge tier-${entry.tier.toLowerCase()}">${entry.tier}</span>${synergyBadge}<span class="pool-card-points">${getWeightedScore(entry, type).toFixed(1)}</span><span class="pool-card-name">${entry.name}</span>`;
    
    // Add synergy info to title
    let synergyInfo = [];
    let hasPositive = false;
    let hasNegative = false;
    for (const synergy of SYNERGIES) {
      if (type === "leader" && entry.name === synergy.leader) {
        const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
        const sign = bonus > 0 ? '+' : '';
        synergyInfo.push(`${sign}${bonus}.0 pts with ${synergy.lore}`);
        if (bonus > 0) hasPositive = true;
        else hasNegative = true;
      } else if (type === "lore" && entry.name === synergy.lore) {
        const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
        const sign = bonus > 0 ? '+' : '';
        synergyInfo.push(`${sign}${bonus}.0 pts with ${synergy.leader}`);
        if (bonus > 0) hasPositive = true;
        else hasNegative = true;
      }
    }
    if (synergyInfo.length > 0) {
      let label = 'Bonuses';
      if (hasPositive && !hasNegative) label = 'Synergies';
      else if (!hasPositive && hasNegative) label = 'Anti-synergies';
      else if (hasPositive && hasNegative) label = 'Synergies/Anti-synergies';
      btn.title = `${label}: ${synergyInfo.join(', ')}`;
    }
    
    btn.addEventListener("click", () => {
      const maxSize = parseInt(type === "leader" ? el.leaderPoolSize.value : el.lorePoolSize.value);
      if (selected.has(entry.name)) {
        selected.delete(entry.name);
        btn.classList.remove("selected");
      } else if (selected.size < maxSize) {
        selected.add(entry.name);
        btn.classList.add("selected");
      }
      updatePoolCounts();
      validateStartButton();
    });
    container.appendChild(btn);
  }
}

function updatePoolCounts() {
  const leaderMax = parseInt(el.leaderPoolSize.value);
  const loreMax = parseInt(el.lorePoolSize.value);
  el.leaderPoolCount.textContent = `(${selectedLeaders.size} / ${leaderMax})`;
  el.lorePoolCount.textContent = `(${selectedLore.size} / ${loreMax})`;
}

function validateStartButton() {
  const leaderMax = parseInt(el.leaderPoolSize.value);
  const loreMax = parseInt(el.lorePoolSize.value);
  const valid = selectedLeaders.size === leaderMax && selectedLore.size === loreMax;
  el.startDraft.disabled = !valid;
}

function randomizePool(type) {
  const maxSize = parseInt(type === "leader" ? el.leaderPoolSize.value : el.lorePoolSize.value);
  const entries = type === "leader" ? allLeaders : allLore;
  const selected = type === "leader" ? selectedLeaders : selectedLore;

  selected.clear();
  const shuffled = [...entries].sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(maxSize, shuffled.length); i++) {
    selected.add(shuffled[i].name);
  }

  renderPoolCards();
  updatePoolCounts();
  validateStartButton();
}

function pickWithConstraint(entries, count, constraint) {
  if (entries.length < count) return null;

  if (constraint === "same") {
    // All cards must be from the same tier
    const tierGroups = new Map();
    for (const e of entries) {
      if (!tierGroups.has(e.tier)) tierGroups.set(e.tier, []);
      tierGroups.get(e.tier).push(e);
    }
    // Find tiers that have enough cards
    const eligible = [...tierGroups.entries()].filter(([, g]) => g.length >= count);
    if (eligible.length === 0) {
      // Fall back to "any" constraint if "same" can't be satisfied
      console.warn(`Cannot satisfy "same" constraint for ${count} cards, falling back to "any"`);
      const shuffled = [...entries].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    }
    const [, group] = eligible[Math.floor(Math.random() * eligible.length)];
    const shuffled = [...group].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
  }

  if (constraint === "unique") {
    // All cards must be from different tiers
    const tierGroups = new Map();
    for (const e of entries) {
      if (!tierGroups.has(e.tier)) tierGroups.set(e.tier, []);
      tierGroups.get(e.tier).push(e);
    }
    const availableTiers = [...tierGroups.keys()];
    if (availableTiers.length < count) {
      // Fall back to "any" constraint if "unique" can't be satisfied
      console.warn(`Cannot satisfy "unique" constraint for ${count} cards (${availableTiers.length} tiers available), falling back to "any"`);
      const shuffled = [...entries].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    }
    // Pick random tiers
    const shuffledTiers = [...availableTiers].sort(() => Math.random() - 0.5);
    const chosenTiers = shuffledTiers.slice(0, count);
    // Pick one random card from each chosen tier
    return chosenTiers.map((t) => {
      const group = tierGroups.get(t);
      return group[Math.floor(Math.random() * group.length)];
    });
  }

  // "any" no constraint, pure random
  const shuffled = [...entries].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

function clearPool(type) {
  const selected = type === "leader" ? selectedLeaders : selectedLore;
  selected.clear();
  renderPoolCards();
  updatePoolCounts();
  validateStartButton();
}

async function generateBalancedDraft() {
  const leaderMax = allLeaders.length; // Use maximum available leaders
  const loreMax = allLore.length; // Use maximum available lore
  const numPlayers = draft.numPlayers;
  const playerLoreLimits = draft.lorePerPlayer === "custom" 
    ? [...draft.customLoreCounts]
    : Array(numPlayers).fill(draft.lorePerPlayer);
  const totalLoreNeeded = playerLoreLimits.reduce((sum, count) => sum + count, 0);
  const acceptableSpread = parseFloat(el.acceptableSpread.value) || 0.5;

  if (allLeaders.length < leaderMax || allLore.length < loreMax) return;
  if (leaderMax < numPlayers || loreMax < totalLoreNeeded) return;

  // Show loading indicator
  setStatus("Generating balanced draft...", { isError: false });
  el.balancedDraft.disabled = true;
  el.balancedDraft.textContent = "Generating... (0/1000)";

  const startTime = Date.now();
  const MAX_TIME = 10000; // 10 seconds timeout
  let timedOut = false;

  // Helper: all permutations of an array
  function permutations(arr) {
    if (arr.length <= 1) return [arr];
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
      for (const perm of permutations(rest)) {
        result.push([arr[i], ...perm]);
      }
    }
    return result;
  }

  // Helper: all ways to choose k items from arr (indices)
  function combinations(arr, k) {
    if (k === 0) return [[]];
    if (arr.length < k) return [];
    const result = [];
    for (let i = 0; i <= arr.length - k; i++) {
      for (const combo of combinations(arr.slice(i + 1), k - 1)) {
        result.push([arr[i], ...combo]);
      }
    }
    return result;
  }

  // Check if leader assignment satisfies tier constraint
  function checkLeaderConstraint(leaderAssignment) {
    if (draft.leaderTierConstraint === "any") return true;
    if (draft.leaderTierConstraint === "same") {
      const firstTier = leaderAssignment[0].tier;
      return leaderAssignment.every(leader => leader.tier === firstTier);
    }
    if (draft.leaderTierConstraint === "unique") {
      const tiers = leaderAssignment.map(leader => leader.tier);
      return new Set(tiers).size === tiers.length;
    }
    return true;
  }

  // Check if lore assignment satisfies tier constraint
  function checkLoreConstraint(loreAssignment) {
    if (draft.loreTierConstraint === "any") return true;
    if (draft.loreTierConstraint === "same") {
      const allLore = loreAssignment.flat();
      if (allLore.length === 0) return true;
      const firstTier = allLore[0].tier;
      return allLore.every(lore => lore.tier === firstTier);
    }
    if (draft.loreTierConstraint === "unique") {
      const allLore = loreAssignment.flat();
      const tiers = allLore.map(lore => lore.tier);
      return new Set(tiers).size === tiers.length;
    }
    return true;
  }

  // Check if scores are within the acceptable range
  function checkScoreRange(scores) {
    const minScore = parseFloat(el.minScore.value) || 0;
    const maxScore = parseFloat(el.maxScore.value) || 100;
    
    // If max is 0, no constraint
    if (maxScore <= 0) return true;
    
    return scores.every(score => score >= minScore && score <= maxScore);
  }

  // For a given pool, find the assignment with acceptable spread
  function findBestAssignment(poolLeaders, poolLore, playerLoreLimits, acceptableSpread) {
    // Pick numPlayers leaders from pool - try all combos, then permutations
    const leaderCombos = combinations(poolLeaders, numPlayers);
    let bestSpread = Infinity;
    let bestAssignment = null;

    for (const leaderCombo of leaderCombos) {
      // Try all permutations of leader assignment to players
      const leaderPerms = permutations(leaderCombo);
      for (const leaderPerm of leaderPerms) {
        // Check leader constraint first
        if (!checkLeaderConstraint(leaderPerm)) continue;

        // Assign lore randomly to players who need them, try multiple random assignments
        const bestLoreAssignment = findBestRandomLoreAssignment(leaderPerm, poolLore, playerLoreLimits);
        if (!bestLoreAssignment) continue;

        // Check lore constraint
        if (!checkLoreConstraint(bestLoreAssignment.lore)) continue;

        // Check score range constraint
        if (!checkScoreRange(bestLoreAssignment.scores)) continue;

        const spread = Math.max(...bestLoreAssignment.scores) - Math.min(...bestLoreAssignment.scores);
        
        // Accept if within acceptable spread range
        if (spread <= acceptableSpread) {
          return { spread, assignment: { 
            leaders: leaderPerm, 
            lore: bestLoreAssignment.lore, 
            scores: [...bestLoreAssignment.scores] 
          }};
        }
        
        // Otherwise track the best we've found so far
        if (spread < bestSpread) {
          bestSpread = spread;
          bestAssignment = { 
            leaders: leaderPerm, 
            lore: bestLoreAssignment.lore, 
            scores: [...bestLoreAssignment.scores] 
          };
        }
      }
    }

    return bestAssignment ? { spread: bestSpread, assignment: bestAssignment } : null;
  }

  // Try random lore assignments and find the one with best score balance
  function findBestRandomLoreAssignment(leaderPerm, poolLore, playerLoreLimits) {
    const RANDOM_ATTEMPTS = 50; // Try 50 random assignments
    let bestSpread = Infinity;
    let bestAssignment = null;

    for (let attempt = 0; attempt < RANDOM_ATTEMPTS; attempt++) {
      const playerScores = leaderPerm.map((l, idx) => getWeightedScore(l, "leader") + ((draft.handicaps[idx] || 0) * draft.leaderWeight));
      const playerLore = leaderPerm.map(() => []);
      let availLore = [...poolLore];

      // For "same" constraint, filter to only one tier
      if (draft.loreTierConstraint === "same" && availLore.length > 0) {
        const randomTier = availLore[Math.floor(Math.random() * availLore.length)].tier;
        availLore = availLore.filter(lore => lore.tier === randomTier);
      }

      // For "unique" constraint, we need to ensure different tiers, but this is complex
      // For now, just shuffle and assign - the constraint check will filter invalid assignments

      // Shuffle the available lore for random assignment
      for (let i = availLore.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [availLore[i], availLore[j]] = [availLore[j], availLore[i]];
      }

      // Assign lore cards randomly to players who need them
      let loreIndex = 0;
      for (let p = 0; p < numPlayers; p++) {
        const needed = playerLoreLimits[p] - playerLore[p].length;
        for (let i = 0; i < needed && loreIndex < availLore.length; i++) {
          playerLore[p].push(availLore[loreIndex]);
          playerScores[p] += getWeightedScore(availLore[loreIndex], "lore");
          loreIndex++;
        }
      }

      // Add synergy bonuses
      for (let p = 0; p < numPlayers; p++) {
        const leader = leaderPerm[p];
        for (const synergy of SYNERGIES) {
          if (leader.name === synergy.leader) {
            const hasLore = playerLore[p].some(l => l.name === synergy.lore);
            if (hasLore) {
              const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
              playerScores[p] += bonus;
            }
          }
        }
      }

      // Check if we assigned enough lore
      const totalAssigned = playerLore.reduce((sum, lore) => sum + lore.length, 0);
      if (totalAssigned < totalLoreNeeded) continue;

      const spread = Math.max(...playerScores) - Math.min(...playerScores);
      if (spread < bestSpread) {
        bestSpread = spread;
        bestAssignment = { lore: playerLore, scores: [...playerScores] };
      }
    }

    return bestAssignment;
  }

  const ATTEMPTS = 1000;
  let bestSpread = Infinity;
  let bestLeaderNames = null;
  let bestLoreNames = null;
  let bestResult = null;

  let attempt = 0;

  function performAttempt() {
    if (attempt >= ATTEMPTS || timedOut || bestSpread <= acceptableSpread) {
      afterLoop();
      return;
    }

    // Update progress every 10 attempts
    if (attempt % 10 === 0) {
      const progressText = `Generating${".".repeat((attempt / 10) % 6)}`;
      el.balancedDraft.textContent = progressText;
    }
    console.log(`Attempt ${attempt + 1}/${ATTEMPTS}`);

    // Check for timeout
    if (Date.now() - startTime > MAX_TIME) {
      timedOut = true;
      afterLoop();
      return;
    }

    // Select pools without constraints first
    const poolLeaders = pickWithConstraint(allLeaders, leaderMax, "any");
    const poolLore = pickWithConstraint(allLore, loreMax, "any");

    const result = findBestAssignment(poolLeaders, poolLore, playerLoreLimits, acceptableSpread);
    if (result) {
      if (result.spread < bestSpread) {
        bestSpread = result.spread;
        bestLeaderNames = poolLeaders.map((c) => c.name);
        bestLoreNames = poolLore.map((c) => c.name);
        bestResult = result.assignment;
      }
    }

    attempt++;
    setTimeout(performAttempt, 0);
  }

  function afterLoop() {
    if (timedOut && bestResult) {
      setStatus(`Generation timed out after 10 seconds. No setup found within ${acceptableSpread} spread. Using best found (spread: ${bestSpread.toFixed(2)}).`, { isError: false });
    } else if (timedOut) {
      setStatus("Generation timed out after 10 seconds. No valid setup found.", { isError: true });
      el.balancedDraft.disabled = false;
      el.balancedDraft.textContent = "Generate Balanced Draft";
      return;
    }

    if (!bestResult) {
      // No valid setup found after all attempts
      setStatus("Could not find a balanced draft with the given constraints. Try relaxing the settings.", { isError: true });
      el.balancedDraft.disabled = false;
      el.balancedDraft.textContent = "Generate Balanced Draft";
      return;
    }

    // Apply the best pool
    selectedLeaders.clear();
    selectedLore.clear();
    for (const n of bestLeaderNames) selectedLeaders.add(n);
    for (const n of bestLoreNames) selectedLore.add(n);

    renderPoolCards();
    updatePoolCounts();
    validateStartButton();

    // Start draft and directly assign the optimal result
    startDraft();
    draft.generatedByBalanced = true;

    // Apply the optimal assignments as picks (no draft order needed)
    for (let p = 0; p < numPlayers; p++) {
      const leader = bestResult.leaders[p];
      draft.players[p].leader = leader;
      draft.availableLeaders = draft.availableLeaders.filter((c) => c.name !== leader.name);
      draft.history.push({ pickIndex: draft.pickIndex, card: { ...leader, pickType: "leader" }, type: "leader", playerIdx: p });
      draft.pickIndex++;

      for (const lore of bestResult.lore[p]) {
        draft.players[p].lore.push(lore);
        draft.availableLore = draft.availableLore.filter((c) => c.name !== lore.name);
        draft.history.push({ pickIndex: draft.pickIndex, card: { ...lore, pickType: "lore" }, type: "lore", playerIdx: p });
        draft.pickIndex++;
      }
    }

    draft.active = false;
    el.undoBtn.disabled = true;
    renderDraft();

    // Reset UI
    el.balancedDraft.disabled = false;
    el.balancedDraft.textContent = "Generate Balanced Draft";
    if (!timedOut) {
      setStatus("Balanced Draft generated successfully!", { isError: false });
    }

    // Scroll to the draft panel
    el.draftPanel.scrollIntoView({ behavior: "smooth", block: "start" });
  }

  performAttempt();
}

// ========== Draft Logic ==========
function startDraft() {
  draft.generatedByBalanced = false;
  draft.order = buildDraftOrder(draft.numPlayers);
  draft.pickIndex = 0;
  draft.history = [];

  draft.players = [];
  for (let i = 0; i < draft.numPlayers; i++) {
    draft.players.push({ leader: null, lore: [] });
  }

  draft.availableLeaders = allLeaders.filter((e) => selectedLeaders.has(e.name));
  draft.availableLore = allLore.filter((e) => selectedLore.has(e.name));
  draft.active = true;

  el.undoBtn.disabled = true;
  el.setupPanel.classList.add("hidden");
  el.draftPanel.classList.remove("hidden");

  renderDraft();
}

function resetDraftToSetup() {
  // Reset draft state but keep setup settings
  draft.active = false;
  draft.pickIndex = 0;
  draft.order = [];
  draft.players = [];
  draft.availableLeaders = [];
  draft.availableLore = [];
  draft.history = [];
  draft.generatedByBalanced = false;

  // Show setup panel
  el.setupPanel.classList.remove("hidden");
  el.draftPanel.classList.add("hidden");

  // Re-render setup UI
  renderPoolCards();
  updatePoolCounts();
  renderDraft(); // This will update the UI
}

function playerDone(player, playerIndex) {
  const requiredLore = getLoreCountForPlayer(playerIndex);
  return player.leader !== null && player.lore.length >= requiredLore;
}

function getPickableCards(playerIdx) {
  const player = draft.players[playerIdx];
  const cards = [];
  // Can pick a leader if don't have one yet
  if (!player.leader) {
    for (const c of draft.availableLeaders) cards.push({ ...c, pickType: "leader" });
  }
  // Can pick lore if haven't filled lore slots
  if (player.lore.length < getLoreCountForPlayer(playerIdx)) {
    for (const c of draft.availableLore) cards.push({ ...c, pickType: "lore" });
  }
  return cards;
}

function getBestPick(playerIdx) {
  const cards = getPickableCards(playerIdx);
  if (cards.length === 0) return null;

  // "Value Above Replacement" approach:
  // For each pickable card, calculate its opportunity cost -
  // the difference between this card's score and the score of
  // the worst card you could realistically end up with in the
  // same category if you skip it now.
  //
  // "Replacement" = the card you'd get if all other players
  // who still need that category pick before you from it.

  const player = draft.players[playerIdx];

  // Count how many OTHER players still need a leader / lore
  let competitorsForLeader = 0;
  let competitorsForLore = 0;
  for (let i = 0; i < draft.numPlayers; i++) {
    if (i === playerIdx) continue;
    if (!draft.players[i].leader) competitorsForLeader++;
    if (draft.players[i].lore.length < getLoreCountForPlayer(i)) competitorsForLore++;
  }

  // Sort available pools by value descending
  const sortedLeaders = [...draft.availableLeaders].sort((a, b) => b.value - a.value);
  const sortedLore = [...draft.availableLore].sort((a, b) => b.value - a.value);

  let bestCard = null;
  let bestOpportunityCost = -Infinity;

  // Number of picks between my current turn and my next turn
  // (in a round, each other player picks once)
  const picksBeforeMyNextTurn = draft.numPlayers - 1;

  for (const card of cards) {
    let opportunityCost;

    if (card.pickType === "leader") {
      // If I skip this leader, it stays in the pool - opponents may take it.
      // At most `competitorsForLeader` opponents want a leader, but only
      // `picksBeforeMyNextTurn` picks happen before I go again, and not all
      // of those will be leaders.
      let cardScore = getWeightedScore(card, "leader");
      // Add synergy bonus if this leader synergizes with current lore
      if (!player.leader) {
        for (const synergy of SYNERGIES) {
          if (card.name === synergy.leader) {
            const hasLore = player.lore.some(l => l.name === synergy.lore);
            if (hasLore) {
              const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
              cardScore += bonus;
            }
          }
        }
        // If no other players need lore, and synergistic lore is available, add bonus for guaranteed future synergy
        if (competitorsForLore === 0) {
          for (const synergy of SYNERGIES) {
            if (card.name === synergy.leader) {
              const loreAvailable = draft.availableLore.some(l => l.name === synergy.lore);
              if (loreAvailable) {
                const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
                cardScore += bonus;
              }
            }
          }
        }
      }
      const leadersTakenBefore = Math.min(competitorsForLeader, picksBeforeMyNextTurn);
      const replacementIdx = leadersTakenBefore;
      if (replacementIdx < sortedLeaders.length) {
        let replacementScore = getWeightedScore(sortedLeaders[replacementIdx], "leader");
        // Add synergy bonus for replacement
        if (!player.leader) {
          for (const synergy of SYNERGIES) {
            if (sortedLeaders[replacementIdx].name === synergy.leader) {
              const hasLore = player.lore.some(l => l.name === synergy.lore);
              if (hasLore) {
                const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
                replacementScore += bonus;
              }
            }
          }
          // If no other players need lore, and synergistic lore is available, add bonus for guaranteed future synergy
          if (competitorsForLore === 0) {
            for (const synergy of SYNERGIES) {
              if (sortedLeaders[replacementIdx].name === synergy.leader) {
                const loreAvailable = draft.availableLore.some(l => l.name === synergy.lore);
                if (loreAvailable) {
                  const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
                  replacementScore += bonus;
                }
              }
            }
          }
        }
        opportunityCost = cardScore - replacementScore;
      } else {
        opportunityCost = cardScore;
      }
    } else {
      // Lore: at most (numPlayers - 1) picks happen before my next turn,
      // and at most `competitorsForLore` of those opponents want lore.
      let cardScore = getWeightedScore(card, "lore");
      // Add synergy bonus if this lore synergizes with current leader
      if (player.leader) {
        for (const synergy of SYNERGIES) {
          if (player.leader.name === synergy.leader && card.name === synergy.lore) {
            const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
            cardScore += bonus;
          }
        }
      } else if (competitorsForLeader === 0) {
        // If no other players need leader, and synergistic leader is available, add bonus for guaranteed future synergy
        for (const synergy of SYNERGIES) {
          if (card.name === synergy.lore) {
            const leaderAvailable = draft.availableLeaders.some(l => l.name === synergy.leader);
            if (leaderAvailable) {
              const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
              cardScore += bonus;
            }
          }
        }
      }
      const loreTakenBefore = Math.min(competitorsForLore, picksBeforeMyNextTurn);
      const replacementIdx = loreTakenBefore;
      if (replacementIdx < sortedLore.length) {
        let replacementScore = getWeightedScore(sortedLore[replacementIdx], "lore");
        // Add synergy bonus for replacement
        if (player.leader) {
          for (const synergy of SYNERGIES) {
            if (player.leader.name === synergy.leader && sortedLore[replacementIdx].name === synergy.lore) {
              const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
              replacementScore += bonus;
            }
          }
        } else if (competitorsForLeader === 0) {
          // If no other players need leader, and synergistic leader is available, add bonus for guaranteed future synergy
          for (const synergy of SYNERGIES) {
            if (sortedLore[replacementIdx].name === synergy.lore) {
              const leaderAvailable = draft.availableLeaders.some(l => l.name === synergy.leader);
              if (leaderAvailable) {
                const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
                replacementScore += bonus;
              }
            }
          }
        }
        opportunityCost = cardScore - replacementScore;
      } else {
        opportunityCost = cardScore;
      }
    }

    if (opportunityCost > bestOpportunityCost) {
      bestOpportunityCost = opportunityCost;
      bestCard = card;
    }
  }

  return bestCard;
}

function advanceDrafter() {
  // Move to next drafter who still needs picks, cycling through the order
  const totalSlots = draft.numPlayers + (draft.lorePerPlayer === "custom" 
    ? draft.customLoreCounts.reduce((sum, count) => sum + count, 0)
    : draft.numPlayers * draft.lorePerPlayer);
  let safety = totalSlots + draft.numPlayers;
  while (safety-- > 0) {
    draft.pickIndex++;
    const drafter = getCurrentDrafter();
    const player = draft.players[drafter - 1];
    if (!playerDone(player, drafter - 1)) return;
  }
  // Everyone done
  draft.active = false;
}

function isDraftComplete() {
  return draft.players.every((p, index) => playerDone(p, index));
}

function makePick(card) {
  const drafter = getCurrentDrafter();
  const playerIdx = drafter - 1;
  const type = card.pickType;

  // Save to history for undo
  draft.history.push({
    pickIndex: draft.pickIndex,
    card,
    type,
    playerIdx,
  });

  // Assign card
  if (type === "leader") {
    draft.players[playerIdx].leader = card;
    draft.availableLeaders = draft.availableLeaders.filter((c) => c.name !== card.name);
  } else {
    draft.players[playerIdx].lore.push(card);
    draft.availableLore = draft.availableLore.filter((c) => c.name !== card.name);
  }

  // Check if draft is complete
  if (isDraftComplete()) {
    draft.active = false;
  } else {
    advanceDrafter();
  }

  el.undoBtn.disabled = false;
  renderDraft();
}

function undoPick() {
  if (draft.history.length === 0) return;

  const last = draft.history.pop();
  draft.pickIndex = last.pickIndex;
  draft.active = true;

  if (last.type === "leader") {
    draft.players[last.playerIdx].leader = null;
    draft.availableLeaders.push(last.card);
    draft.availableLeaders.sort((a, b) => b.value - a.value);
  } else {
    draft.players[last.playerIdx].lore.pop();
    draft.availableLore.push(last.card);
    draft.availableLore.sort((a, b) => b.value - a.value);
  }

  el.undoBtn.disabled = draft.history.length === 0;
  renderDraft();
}

function undoAllPicks() {
  while (draft.history.length > 0) {
    const last = draft.history.pop();
    draft.pickIndex = last.pickIndex;
    draft.active = true;

    if (last.type === "leader") {
      draft.players[last.playerIdx].leader = null;
      draft.availableLeaders.push(last.card);
      draft.availableLeaders.sort((a, b) => b.value - a.value);
    } else {
      draft.players[last.playerIdx].lore.pop();
      draft.availableLore.push(last.card);
      draft.availableLore.sort((a, b) => b.value - a.value);
    }
  }
  el.undoBtn.disabled = true;
  renderDraft();
}

function autoDraft() {
  if (!draft.active) return;
  let safety = 200;
  while (draft.active && safety-- > 0) {
    const drafter = getCurrentDrafter();
    const playerIdx = drafter - 1;
    const best = getBestPick(playerIdx);
    if (!best) break;

    // Apply pick directly (no render per pick)
    draft.history.push({
      pickIndex: draft.pickIndex,
      card: best,
      type: best.pickType,
      playerIdx,
    });

    if (best.pickType === "leader") {
      draft.players[playerIdx].leader = best;
      draft.availableLeaders = draft.availableLeaders.filter((c) => c.name !== best.name);
    } else {
      draft.players[playerIdx].lore.push(best);
      draft.availableLore = draft.availableLore.filter((c) => c.name !== best.name);
    }

    if (isDraftComplete()) {
      draft.active = false;
    } else {
      advanceDrafter();
    }
  }

  el.undoBtn.disabled = draft.history.length === 0;
  renderDraft();
}

// ========== Draft Rendering ==========
function renderDraft() {
  el.saveDraftImg.style.display = draft.active ? "none" : "";
  el.resetDraft.textContent = draft.generatedByBalanced ? "Regenerate" : "Reset";
  renderPhaseLabel();
  renderPlayerBoards();
  renderAvailableCards();
}

function renderPhaseLabel() {
  if (!draft.active) {
    el.draftPhaseLabel.textContent = "Draft Complete!";
    // Scroll to keep the completion message and buttons visible with some margin
    setTimeout(() => {
      const rect = el.draftPanel.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const targetY = scrollTop + rect.top - 80; // 80px margin from top
      window.scrollTo({ top: targetY, behavior: 'smooth' });
    }, 100);
    return;
  }
  const drafter = getCurrentDrafter();
  const isYou = drafter === draft.mySeat;
  const player = draft.players[drafter - 1];
  const needs = [];
  if (!player.leader) needs.push("Leader");
  const loreLeft = getLoreCountForPlayer(drafter - 1) - player.lore.length;
  if (loreLeft > 0) needs.push(`Lore (${loreLeft} left)`);
  const pickNum = draft.history.length + 1;
  el.draftPhaseLabel.innerHTML = `Pick #${pickNum} <strong>Player ${drafter}${isYou ? " (You)" : ""}</strong> · Needs: ${needs.join(", ")}`;
}

function renderPlayerBoards() {
  el.playerBoards.innerHTML = "";
  el.playerBoards.dataset.players = draft.numPlayers;

  for (let i = 0; i < draft.numPlayers; i++) {
    const player = draft.players[i];
    const playerNum = i + 1;
    const isYou = playerNum === draft.mySeat;
    const isActive = draft.active && getCurrentDrafter() === playerNum;

    const board = document.createElement("div");
    board.className = "player-board";
    if (isActive) board.classList.add("active-drafter");
    if (isYou) board.classList.add("is-you");

    const score = playerTotalScore(player, i).toFixed(1);

    let picksHTML = "";

    // Leader slot
    if (player.leader) {
      const imgUrl = player.leader.card ? getImageUrl(player.leader.card) : null;
      const imgTag = imgUrl ? `<img class="player-pick-img" src="${imgUrl}" alt="${player.leader.name}" />` : "";
      
      // Check for synergy star
      let hasSynergy = false;
      for (const synergy of SYNERGIES) {
        if (player.leader.name === synergy.leader) {
          const hasLore = player.lore.some(l => l.name === synergy.lore);
          if (hasLore) {
            hasSynergy = true;
            break;
          }
        }
      }
      
      picksHTML += `<div class="player-pick">
        ${imgTag}
        <div class="player-pick-details">
          <div class="pick-header">
            <span class="pick-type">Lead</span>
            ${hasSynergy ? '<span class="synergy-badge-small">★</span>' : ''}
            <span class="tier-badge tier-${player.leader.tier.toLowerCase()}">${player.leader.tier}</span>
            <span class="pick-name">${player.leader.name}</span>
          </div>
          <div class="pick-points-line">${getWeightedScore(player.leader, "leader").toFixed(1)} pts</div>
        </div>
      </div>`;
    } else {
      picksHTML += `<div class="player-pick-empty">No leader yet</div>`;
    }

    // Lore slots
    const loreCount = getLoreCountForPlayer(i);
    for (let j = 0; j < loreCount; j++) {
      if (player.lore[j]) {
        const imgUrl = player.lore[j].card ? getImageUrl(player.lore[j].card) : null;
        const imgTag = imgUrl ? `<img class="player-pick-img" src="${imgUrl}" alt="${player.lore[j].name}" />` : "";
        
        // Check for synergy star
        let hasSynergy = false;
        if (player.leader) {
          for (const synergy of SYNERGIES) {
            if (player.leader.name === synergy.leader && player.lore[j].name === synergy.lore) {
              hasSynergy = true;
              break;
            }
          }
        }
        
        picksHTML += `<div class="player-pick">
          ${imgTag}
          <div class="player-pick-details">
            <div class="pick-header">
              <span class="pick-type">Lore</span>
              ${hasSynergy ? '<span class="synergy-badge-small">★</span>' : ''}
              <span class="tier-badge tier-${player.lore[j].tier.toLowerCase()}">${player.lore[j].tier}</span>
              <span class="pick-name">${player.lore[j].name}</span>
            </div>
            <div class="pick-points-line">${getWeightedScore(player.lore[j], "lore").toFixed(1)} pts</div>
          </div>
        </div>`;
      } else {
        picksHTML += `<div class="player-pick-empty">Lore ${j + 1}</div>`;
      }
    }

    // Add handicap display if applicable
    const handicap = draft.handicaps[i] || 0;
    if (handicap > 0) {
      const handicapBonus = (handicap * draft.leaderWeight).toFixed(1);
      picksHTML += `<div class="player-handicap">Handicapped (${handicap}): +${handicapBonus} pts</div>`;
    }

    // Add synergy display if applicable
    const synergyBonus = getSynergyBonus(draft.players[i]);
    if (synergyBonus !== 0) {
      const sign = synergyBonus > 0 ? '+' : '';
      const label = synergyBonus > 0 ? 'Synergies' : 'Anti-synergies';
      picksHTML += `<div class="player-synergy">${label}: ${sign}${synergyBonus.toFixed(1)} pts</div>`;
    }

    board.innerHTML = `
      <div class="player-name">
        <span>Player ${playerNum} ${isYou ? '<span class="player-you-badge">YOU</span>' : ""}</span>
        <span class="player-score">${score} pts</span>
      </div>
      <div class="player-picks">${picksHTML}</div>
    `;

    el.playerBoards.appendChild(board);
  }
}

function renderAvailableCards() {
  el.availableCards.innerHTML = "";

  if (!draft.active) {
    // Show completion summary
    const myPlayer = draft.players[draft.mySeat - 1];
    const myScore = playerTotalScore(myPlayer, draft.mySeat - 1).toFixed(1);

    const scores = draft.players.map((p, i) => ({
      player: i + 1,
      score: playerTotalScore(p, i),
    })).sort((a, b) => b.score - a.score);

    const rank = scores.findIndex((s) => s.player === draft.mySeat) + 1;

    const summary = document.createElement("div");
    summary.className = "draft-complete";
    summary.innerHTML = `
      <h3>Draft Complete!</h3>
      <div class="draft-result-score">${myScore} pts</div>
      <p>Your draft ranked <strong>#${rank}</strong> of ${draft.numPlayers} players</p>
    `;
    el.availableCards.appendChild(summary);
    return;
  }

  const drafterIdx = getCurrentDrafter() - 1;
  const pickable = getPickableCards(drafterIdx);
  const best = getBestPick(drafterIdx);

  // Split into leaders and lore for display
  const leaderCards = pickable.filter((c) => c.pickType === "leader").sort((a, b) => b.value - a.value);
  const loreCards = pickable.filter((c) => c.pickType === "lore").sort((a, b) => b.value - a.value);

  function renderCardGroup(cards, label) {
    if (cards.length === 0) return;
    const sep = document.createElement("div");
    sep.className = "draft-separator";
    sep.textContent = label;
    el.availableCards.appendChild(sep);

    for (const card of cards) {
      const isRec = best && card.name === best.name && card.pickType === best.pickType;
      const imgUrl = card.card ? getImageUrl(card.card) : null;
      let score = getWeightedScore(card, card.pickType);
      
      // Check for synergies
      let showsSynergy = false;
      for (const synergy of SYNERGIES) {
        if ((card.pickType === "leader" && card.name === synergy.leader) || (card.pickType === "lore" && card.name === synergy.lore)) {
          // Check if the partner card is available or picked
          let partnerAvailable = false;
          if (card.pickType === "leader") {
            // For leader, check if lore is available or picked
            partnerAvailable = draft.availableLore.some(l => l.name === synergy.lore) || 
                               draft.players.some(p => p.lore.some(l => l.name === synergy.lore));
          } else {
            // For lore, check if leader is available or picked
            partnerAvailable = draft.availableLeaders.some(l => l.name === synergy.leader) || 
                               draft.players.some(p => p.leader && p.leader.name === synergy.leader);
          }
          if (partnerAvailable) {
            showsSynergy = true;
            break;
          }
        }
      }
      
      // Add synergy bonus for current drafter
      const drafter = draft.players[drafterIdx];
      if (card.pickType === "leader" && !drafter.leader) {
        // Check if this leader synergizes with any of drafter's lore
        for (const synergy of SYNERGIES) {
          if (card.name === synergy.leader) {
            const hasLore = drafter.lore.some(l => l.name === synergy.lore);
            if (hasLore) {
              const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
              score += bonus;
            }
          }
        }
      } else if (card.pickType === "lore" && drafter.leader) {
        // Check if this lore synergizes with drafter's leader
        for (const synergy of SYNERGIES) {
          if (drafter.leader.name === synergy.leader && card.name === synergy.lore) {
            const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
            score += bonus;
          }
        }
      }
      
      const displayScore = score.toFixed(1);

      const div = document.createElement("div");
      div.className = `draft-card draft-${card.pickType}${isRec ? " recommended" : ""}`;

      // Add synergy info to title
      if (showsSynergy) {
        let synergyInfo = [];
        let hasPositive = false;
        let hasNegative = false;
        for (const synergy of SYNERGIES) {
          if (card.pickType === "leader" && card.name === synergy.leader) {
            const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
            const sign = bonus > 0 ? '+' : '';
            synergyInfo.push(`${sign}${bonus}.0 pts with ${synergy.lore}`);
            if (bonus > 0) hasPositive = true;
            else hasNegative = true;
          } else if (card.pickType === "lore" && card.name === synergy.lore) {
            const bonus = typeof synergy.bonus === 'function' ? synergy.bonus(draft.numPlayers) : synergy.bonus;
            const sign = bonus > 0 ? '+' : '';
            synergyInfo.push(`${sign}${bonus}.0 pts with ${synergy.leader}`);
            if (bonus > 0) hasPositive = true;
            else hasNegative = true;
          }
        }
        if (synergyInfo.length > 0) {
          let label = 'Bonuses';
          if (hasPositive && !hasNegative) label = 'Synergies';
          else if (!hasPositive && hasNegative) label = 'Anti-synergies';
          else if (hasPositive && hasNegative) label = 'Synergies/Anti-synergies';
          div.title = `${label}: ${synergyInfo.join(', ')}`;
        }
      }

      let imgHTML = "";
      if (imgUrl) {
        imgHTML = `<img class="draft-card-img" src="${imgUrl}" alt="${card.name}" loading="lazy" />`;
      } else {
        imgHTML = `<div class="draft-card-img" style="display:flex;align-items:center;justify-content:center;background:var(--bg-solid);font-size:0.7rem;color:var(--text-muted);padding:8px;">${card.name}</div>`;
      }

      div.innerHTML = `
        ${isRec ? '<div class="draft-card-rec-badge">Best</div>' : ""}
        ${showsSynergy ? '<span class="synergy-badge">★</span>' : ""}
        ${imgHTML}
        <div class="draft-card-info">
          <div class="draft-card-name">${card.name}</div>
          <div class="draft-card-score">${displayScore} pts · ${card.tier}</div>
        </div>
      `;

      div.addEventListener("click", () => makePick(card));
      el.availableCards.appendChild(div);
    }
  }

  renderCardGroup(leaderCards, "Leaders");
  renderCardGroup(loreCards, "Lore");
}

async function loadCustomTierData(mode) {
  try {
    el.customTierStatus.textContent = "Loading…";
    el.customTierStatus.style.color = "var(--text-muted)";
    let csvText = el.customTierText.value.trim();
    const url = el.customTierUrl.value.trim();

    if (url && !csvText) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch URL (${res.status})`);
      csvText = await res.text();
    }

    if (!csvText) {
      el.customTierStatus.textContent = "Provide a URL or paste CSV.";
      el.customTierStatus.style.color = "var(--red, #f87171)";
      return;
    }

    const parsed = Papa.parse(csvText, { header: false, skipEmptyLines: false });
    const rows = parsed.data ?? [];
    const cards = await loadCards();
    const result = parseTierData(rows, cards);

    let leadersToLoad = [];
    if (mode === "3p") {
      leadersToLoad = result.leaders3P;
    } else if (mode === "4p") {
      leadersToLoad = result.leaders4P;
    } else {
      // Combined mode (fallback)
      leadersToLoad = [...result.leaders3P, ...result.leaders4P];
    }

    if (leadersToLoad.length === 0 && result.lore.length === 0) {
      el.customTierStatus.textContent = "No valid tier data found.";
      el.customTierStatus.style.color = "var(--red, #f87171)";
      return;
    }

    customLeaders = leadersToLoad;
    customLore = result.lore;
    const modeText = mode === "3p" ? "3P" : mode === "4p" ? "4P" : "";
    el.customTierStatus.textContent = `Loaded ${customLeaders.length} ${modeText} leaders, ${customLore.length} lore ✓`;
    el.customTierStatus.style.color = "var(--accent)";
    applyTierSource();
  } catch (err) {
    console.error(err);
    el.customTierStatus.textContent = `Error: ${err.message}`;
    el.customTierStatus.style.color = "var(--red, #f87171)";
  }
}

function applyTierSource() {
  if (draft.tierSource === "data") {
    allLeaders = dataLeaders;
    allLore = dataLore;
  } else if (draft.tierSource === "Community3p") {
    allLeaders = Community3pLeaders;
    allLore = Community3pLore;
  } else if (draft.tierSource === "Community4p") {
    allLeaders = Community4pLeaders;
    allLore = Community4pLore;
  } else if (draft.tierSource === "personal3p") {
    allLeaders = personal3PLeaders;
    allLore = personalLore;
  } else if (draft.tierSource === "personal4p") {
    allLeaders = personal4PLeaders;
    allLore = personalLore;
  } else if (draft.tierSource === "custom") {
    allLeaders = customLeaders;
    allLore = customLore;
  } else {
    allLeaders = personalLeaders;
    allLore = personalLore;
  }
  // Re-assign values with current scoring mode
  assignValues(allLeaders);
  assignValues(allLore);
  // Clear selections that don't exist in the new source
  const leaderNames = new Set(allLeaders.map((e) => e.name));
  const loreNames = new Set(allLore.map((e) => e.name));
  for (const name of [...selectedLeaders]) {
    if (!leaderNames.has(name)) selectedLeaders.delete(name);
  }
  for (const name of [...selectedLore]) {
    if (!loreNames.has(name)) selectedLore.delete(name);
  }
  renderPoolCards();
  updatePoolCounts();
  validateStartButton();
}

// ========== Export Image ==========
async function saveDraftAsImage() {
  const btn = el.saveDraftImg;
  const origText = btn.textContent;
  btn.disabled = true;
  btn.textContent = "Saving…";

  try {
    const target = el.playerBoards;

    // Wait for all images to finish loading
    const imgs = target.querySelectorAll("img");
    await Promise.all(
      Array.from(imgs).map(
        (img) =>
          new Promise((resolve) => {
            if (img.complete) return resolve();
            img.onload = resolve;
            img.onerror = resolve;
          })
      )
    );

    const blob = await toBlob(target, {
      pixelRatio: 2,
      backgroundColor:
        document.documentElement.dataset.theme === "light"
          ? "#f5f7fa"
          : "#0a0e1a",
      cacheBust: true,
    });

    if (!blob) throw new Error("Capture failed");

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `arcs-draft-${draft.numPlayers}p.png`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error("Save failed:", err);
    alert("Failed to save draft image. Try again.");
  } finally {
    btn.disabled = false;
    btn.textContent = origText;
  }
}

// ========== Init ==========
async function init() {
  initTheme();
  el.themeToggle.addEventListener("click", toggleTheme);

  el.resetDraft.addEventListener("click", () => {
    if (draft.generatedByBalanced) {
      generateBalancedDraft();
    } else {
      undoAllPicks();
    }
  });

  el.resetAllBtn.addEventListener("click", () => {
    window.location.href = window.location.href;
  });
  el.autoDraftBtn.addEventListener("click", autoDraft);
  el.undoBtn.addEventListener("click", undoPick);
  el.saveDraftImg.addEventListener("click", saveDraftAsImage);

  try {
    setStatus("Loading cards & tier data…");
    const [cards, tierRows, rankedRows] = await Promise.all([
      loadCards(),
      loadTierList(),
      loadRankedSheet(),
    ]);

    const personal = parseTierData(tierRows, cards);
    personalLeaders = [...personal.leaders3P, ...personal.leaders4P]; // For backward compatibility
    personalLore = personal.lore;
    personal3PLeaders = personal.leaders3P;
    personal4PLeaders = personal.leaders4P;
    personalBasecourt = personal.basecourt;

    const ranked = parseRankedData(rankedRows, cards);
    dataLeaders = ranked.leaders;
    dataLore = ranked.lore;

    // Parse Community tier data (static, no fetch needed)
    const comm3p = parseCommunityTierData("3p", cards);
    Community3pLeaders = comm3p.leaders;
    Community3pLore = comm3p.lore;

    const comm4p = parseCommunityTierData("4p", cards);
    Community4pLeaders = comm4p.leaders;
    Community4pLore = comm4p.lore;

    if (personalLeaders.length === 0 && personalLore.length === 0 &&
        dataLeaders.length === 0 && dataLore.length === 0 &&
        Community4pLeaders.length === 0 && Community4pLore.length === 0) {
      setStatus("No tier list data found.", { isError: true });
      return;
    }

    // Apply default source
    applyTierSource();

    setStatus("");
    initSetupUI();
    updateHandicapSliders();
    // Initialize range displays
    el.minScoreDisplay.textContent = el.minScore.value;
    el.maxScoreDisplay.textContent = el.maxScore.value;
    renderPoolCards();
    updatePoolCounts();
  } catch (err) {
    console.error(err);
    setStatus(`Error: ${err.message}`, { isError: true });
  }
}

init();
